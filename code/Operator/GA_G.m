function Offspring = GA_G(Parent,External)
%GA - Genetic operators for real, binary, and permutation based encodings.
%
%   Off = GA(P) returns the offsprings generated by genetic operators,
%   where P1 is a set of parents. If P is an array of INDIVIDUAL objects,
%   then Off is also an array of INDIVIDUAL objects; while if P is a matrix
%   of decision variables, then Off is also a matrix of decision variables,
%   i.e., the offsprings will not be evaluated. P is split into two subsets
%   P1 and P2 with the same size, and each object/row of P1 and P2 is used
%   to generate TWO offsprings. Different operators are used for real,
%   binary, and permutation based encodings, respectively.
%
%   Example:
%       Off = GA(Parent)
%       Off = GA(Parent.decs,{1,20,1,20})
%
%   See also GAhalf


    %% Parameter setting
    if nargin == 1
        [~,index] = min(Parent.objs,[],1);
        Guide     = Parent(index).dec;   % 目标函数最小的个体作为引导个体
        Parent    = Parent.decs; 
    else
        Guide     = External.decs;
        Parent    = Parent.decs; 
    end

%     if isa(Parent(1),'INDIVIDUAL') % 判断Parent(1)是否为INDIVIDUAL类型的对象       
%         calObj = true;
%     else
%         calObj = false;
%     end
    Parent1 = Parent(1:floor(end/2),:);
    Parent2 = Parent(floor(end/2)+1:floor(end/2)*2,:);
    [N,D]   = size(Parent1);
    Global  = GLOBAL.GetObj();
 
    switch Global.encoding  
        
%         case 'integer3'
%             Offspring = CrossoverOperation_logistic(Parent,0.8,Guide,{'Guide1','Guide2','Guide3'});
%             Offspring = MutationOperation_logistic(Offspring,0.1,Global,{'Swap'}); 
        case 'integer2'
            
            Offspring = CrossoverOperation(Parent,Global.pc,Guide,{'Guide1','Guide2'});
            
            Offspring = MutationOperation(Offspring,Global.pm,Global.ETC.available,{'Swap'});
%             
            
        otherwise
            %% Genetic operators for real encoding
            % Simulated binary crossover
            beta = zeros(N,D);
            mu   = rand(N,D);
            beta(mu<=0.5) = (2*mu(mu<=0.5)).^(1/(disC+1));
            beta(mu>0.5)  = (2-2*mu(mu>0.5)).^(-1/(disC+1));
            beta = beta.*(-1).^randi([0,1],N,D);
            beta(rand(N,D)<0.5) = 1;
            beta(repmat(rand(N,1)>proC,1,D)) = 1;
            Offspring = [(Parent1+Parent2)/2+beta.*(Parent1-Parent2)/2
                         (Parent1+Parent2)/2-beta.*(Parent1-Parent2)/2];
            % Polynomial mutation
            Lower = repmat(Global.lower,2*N,1);
            Upper = repmat(Global.upper,2*N,1);
            Site  = rand(2*N,D) < proM/D;
            mu    = rand(2*N,D);
            temp  = Site & mu<=0.5;
            Offspring       = min(max(Offspring,Lower),Upper);
            Offspring(temp) = Offspring(temp)+(Upper(temp)-Lower(temp)).*((2.*mu(temp)+(1-2.*mu(temp)).*...
                              (1-(Offspring(temp)-Lower(temp))./(Upper(temp)-Lower(temp))).^(disM+1)).^(1/(disM+1))-1);
            temp = Site & mu>0.5; 
            Offspring(temp) = Offspring(temp)+(Upper(temp)-Lower(temp)).*(1-(2.*(1-mu(temp))+2.*(mu(temp)-0.5).*...
                              (1-(Upper(temp)-Offspring(temp))./(Upper(temp)-Lower(temp))).^(disM+1)).^(1/(disM+1)));
    end
    
%     if calObj
        Offspring = INDIVIDUAL(Offspring);
%     end
end